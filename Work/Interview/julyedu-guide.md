# 七月算法相关讲解

## 面试指南

+ 基础知识(笔试)
    + 操作系统、数据库、网络
+ 算法
    + 贪心、分治、动态规划、回溯
    + dfs、bfs
    + 字符串处理
    + 线性表(链表、堆栈、队列)、树
    + 排列组合概率
    + 少见：线段树、网络流
+ 非编程问题
    + 迅速给出一个不很完美的解决方案
    + 和面试官交流

**别太钻研难题，做好『简单题』**

**别钻研太复杂的算法**

### O(n) 时间能做什么

+ 判断一个数组是否为 1~N 的一个排列（可以用 O(1) 空间）
+ 寻找 1~N 第一个不在数组内的数字（可以用 O(1) 空间）
+ 寻找众数，缺失的数字(xor, hash)
+ 字符串循环移位
+ KMP 串匹配
+ 最大直方图
+ 动规-最近 m 个数中最大的
+ 最长回文子串，以及回文串的个数
+ 框算法
+ 计数排序
+ 快排的 partition - 荷兰国旗问题，中位数问题
+ 建立堆（注意，这是 O(n) 的）
+ 和树相关的问题，二叉树最近公共祖先，树的遍历，树的高度
+ 2-sum（允许用 hash 的话，期望复杂度是 O(n)）
+ 完美洗牌
+ 最大连续乘积子数组
+ 杨氏矩阵查找
+ 出现超过一半的数字
+ Manacher


### 各类算法的时间复杂度

+ O(1)
    + 基本运算，寻址
    + Hash 表的期望复杂度
+ O(logn)
    + 二分查找
+ O(n)
    + 线性查找
    + 其他见上面
+ O(nlogn)
    + 归并排序
    + 快速排序的期望复杂度
    + 基于比较排序的算法下界
+ O(n^2)
    + 集合里枚举所有二元组
    + 朴素最近点对
+ O(n^3)
    + 集合里枚举三元组
    + Floyd 最短路径
    + 普通矩阵乘法
+ O(2^n)
    + 枚举全部的子集
+ O(n*2^n)
    + TSP 动态规划算法
+ O(n!)
    + 枚举全排列
+ O(n^n)
    + 枚举 [1...n] 的 n 维数组的全部元素



## 常见字符串问题

### 字符串循环右移

**方法一**

右移 x 位可以看成把前 x 位移动到后面的结果。

可以用一个数组保存前 x 位，然后把后面 n-x 位移动到前面，最后再把那 x 位放到后面

时间复杂度 O(n)，空间复杂度 O(n)

**方法二**

右移 x 位等价于右移 x%n 位

用三次翻转解决问题

+ 先翻转前面 x%n 位
+ 再翻转后面 n - x%n 位
+ 再把整个字符串翻转

时间复杂度 O(n)，空间复杂度 O(1)

### 最长回文子串

**暴力方法一**

+ 枚举起点 O(n)
+ 枚举中点 O(n)
+ 判断回文 O(n)
+ 总复杂度 O(n^3)

**暴力方法二**

+ 枚举中间点 O(n)，可能是两个字符，可能是一个字符
+ 不断延伸判断回文 O(n)
+ 总复杂度 O(n^2)

**Manacher 方法**

O(n)时间复杂度。奇数偶数统一处理，在每个字符前后都插入一个额外的标识符

+ 例如字符 aba 变为 #a#b#a#
+ 定义数组 p[i]，表示以 i 为中心 [i-x ... i+x] 是最长且回文的
+ #a#b#a#
+ 0103010
+ p[i] 其实表示了原串中以该字符为中心的最长回文子串的长度(#表示原串中两个字符之间的位置为中心)
+ 具体的算法单开一节来介绍


## 常见序列问题

技巧：二分、排序、暴力未尝不可、胆大心细

### K 序列合并

把 K 个有序数列合并成一个有序数列，元素共有 N 个。

**分析**

+ 每个数列的元素都从左到右移到新的数列中
+ 把每个数列的当前元素放入堆中，每次删除最小值并放入新数列中，然后加入此数列的下一个元素
+ 时间复杂度：O(NlogK)

### 序列和的前 N 小元素

+ 给出两个长度为 N 的有序数列 A 和 B，在 A 和 B 中各任取一个元素，可以得到 N^2 个和
+ 求这些和最小的 N 个

**分析**

可以把这些和看成 N 个有序数列：

    A[1]+B[1] <= A[1]+B[2] <= A[1]+B[3] <= ...
    A[2]+B[1] <= A[2]+B[2] <= A[2]+B[3] <= ...
    ...
    A[N]+B[1] <= A[N]+B[2] <= A[N]+B[3] <= ...

然后类似刚才的算法，每次 O(logN)，共取 N 次最小元素

时间复杂度：O(NlogN)

### 多序列第 K 个元素

+ 有 M 个有序数列，每个数列里有 N 个元素
+ 所有元素不超过 W
+ 求将 M*N 个元素排序后第 K 个元素的值

**分析**

二分元素大小 x

计算每个数列里比 x 小的元素个数 k' (二分查找)，共计 O(MlogN)

+ 如果 k' = k，输出 x
+ 如果 k' < k，x 增大
+ 如果 k' > k，x 减小

时间复杂度：O(MlogNlogW)

### 区间染色

+ 有 N 个闭区间[ai, bi]，每一段被涂成黑色
+ 求整个数轴被涂成几段黑色

**分析**

+ 按左端点从左到右排序
+ 从左到右扫描，若下一个区间的左端点分离，则区间数加一，否则扩展当前区间的右端点
+ 时间复杂度：O(NlogN)

### 区间查询(难)

+ 给 N 个数 A[1...N]
+ 设计在线算法，对于询问(i, j, k)，返回 A[i...j] 的元素排序后的第 K 个元素

**分析**

+ 简历线段树，每个线段保存该区间内元素排序好的数列
+ 查询处理：任意 [i, j] 可 分解为最多 2logN 个不重叠区间的并。只需二分 W，每次计算 2logN 个区间内一共有多少个数比 W 大，用 logW 次时间可求出第 K 个元素
+ 区间内的数已排序，用二分每个区间求比 W 大的数 logN
+ 累加所有 2logN 个区间比 W 大的数，共 log_2 N
+ 时间：O(logWlog_2 N)
+ 空间：O(NlogN)

### 模式匹配

+ 给定字符串 T，寻找串 P 是否在 T 中出现
+ T 称为母串，P 称为模板
+ 一般记 T 和 P 的长度为 N 和 M

**分析**

+ 依次判断  T 从第 i 个字符开始的长度为 M 的串是否和 P 相同
+ 判断字符串相同：O(N)
+ 枚举起点：O(N)
+ 最坏情况：O(N^2)

但是这里可以利用 KMP 算法来减少重复的匹配，KMP 算法具体再说

### 公共子串(难)

+ 有 N 个长度不超过 L 的单词
+ 求所有单词中最长的公共子串

**分析**

+ 枚举最短子串再用 KMP：O(NL^3)
+ 枚举所求串在最短子串中的开始位置，取其他串 KMP 结果(最远能匹配到的位置)的最小值为结束位置：O(NL^2)
