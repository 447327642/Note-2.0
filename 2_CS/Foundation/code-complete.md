# 代码大全(第二版) Code Complete

在这里不会按照书本的分类每一章都进行总结，而是挑选那些在我现在的水平看来比较有意义，还不算过时的内容。并且关于概念等大道理的部分会比较简略，重点会着眼与编码的一些经验和技巧

## 第 1 章 欢迎进入软件构建的世界 Welcome to Software Construction

+ 软件构建是软件开发的核心活动；构建活动是每个项目中唯一一项必不可少的工作
+ 构建活动主要是编码与调试，但也涉及详细设计、规划构建、单元测试、集成、集成测试等其他活动
+ 构建也常被称作『编码』和『编程』
+ 构建活动的质量对软件的质量有着实质性的影响
+ 你对『如何进行构建』的理解程度，决定了你这名程序员的优秀程度

## 第 2 章 用隐喻来更充分地理解软件开发 Metaphors for a Richer Understanding of Software Development

重要的研发成果常常来自类比(analogy)。你对隐喻有多理解，也就决定了你对软件开发有多理解。

+ 隐喻是启示而不是算法，因此它们往往有一点随意(sloopy)
+ 隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解
+ 有些隐喻比其他一些隐喻更贴切
+ 通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的
+ 通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确的工具是成为能有效编程的程序员的关键
+ 不同的隐喻并不排斥，应当使用对你最有益处的某种隐喻组合

## 第 3 章 三思而后行：前期准备 Measure Twice, Cut Once: Upstream Prerequisites

### 架构的典型组成部分 Typical Architectual Components

+ 程序组织 Program Organization
	+ 应该明确定义各个构造快的责任。每个构造快应该负责一个区域的事情，并且对其他构造块负责的区域知道的越少越好
+ 主要的类 Major Classes
+ 数据设计 Data Design
	+ 数据通常只应该由一个子系统或一个类直接访问
+ 业务规则 Business Rules
+ 用户界面设计 User Interface Design
	+ 架构应该模块化，以便在替换为新用户界面时不影响业务规则和程序的输出部分
+ 资源管理 Resource Management
+ 安全性 Security
+ 性能 Performance
+ 可伸缩性 Scalability
+ 互用性 Interoperability
+ 国际化/本地化 Internationalization/Localization
+ 输入输出 Input/Output
+ 错误处理 Error Processing
+ 容错性 Fault Tolerance
+ 架构的可行性 Architectural Feasibility
+ 过度工程 Overengineering
+ 关于『买』还是『造』的决策 Buy-vs.-Build Decisions
+ 关于复用的决策 Reuse Decisions
+ 变更策略 Change Strategy
+ 架构的总体质量 General Architectural Quality

### 要点

+ 构建活动的准备工作的根本目标在于降低风险
+ 软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大
+ 如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题
+ 如果没有做完良好的需求分析工作，你可能没能察觉待解决的问题的重要细节
+ 如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题
+ 理解项目的前期准备所采用的方法，并相应地选择构建方法

## 第 4 章 关键的『构建』决策 Key Construction Decisions

+ 每种编程语言都有其优点和弱点
+ 在开始编程之前，做好一些约定(convention)
+ 『构建的实践方法』的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法
+ 记得『深入一种语言去编程』，不要仅『在一种语言上编程』
+ 你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标

---

## 第 5 章 软件构建中的设计 Design in Construction

### 理想的设计特征 Desirable Characteristics of a Design

+ **最小的复杂度(Minimal complexity)**。应该做出简单且易于理解的设计。如果你的设计方案不能让你在专注于程序的一部分时安心地忽视其他部分的话，这一设计就没有什么作用
+ **易于维护(Ease of maintenance)**。设计出能自明(self-explanatory)的系统
+ **松散耦合(Loose coupling)**。设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象、封装性及信息隐藏等原则，设计出相互关联尽可能最少的类。减少关联也就减少了集成、测试与维护时的工作量
+ **可拓展性(Extensibility)**。能够增强系统的功能而无须破坏其底层结构
+ **可重用性(Reusability)**。所设计的系统的组成部分能在其他系统中重复使用
+ **高扇入(High fan-in)**。让大量的类使用某个给定的类。这意味着设计出的系统很好地利用了在较低层次上的工具类(utility classes)
+ **低扇出(Low fan-out)**。让一个类里少量或适中地使用其他的类
+ **可移植性(Portability)**。应该这样设计系统，使它能很方便地移植到其他环境中
+ **精简性(Leanness)**。设计出的系统没有多余的部分
+ **层次性(Stratification)**。尽量保持系统各个分解层的层次性，使你能在任意的层面上观察系统，并得到某种具有一致性的看法
+ **标准技术(Standard techniques)**。一个系统所依赖的外来的、古怪的东西越多，别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的、常用的方法，让整个系统给人一种熟悉的感觉

### 设计的层次 Levels of Design

一个程序中的设计层次。**系统**首先被组织为**子系统**；**子系统**被进一步分解为**类**，然后**类**又被分解为**子程序**和**数据**。每个**子程序**的内部也需要进行设计。

+ 第 1 层：软件系统 Software System
	+ 先从子系统或者**包(package)**这些类的更高组织层次来思考会更有益处
+ 第 2 层：分解为子系统或包 Division into Subsystems or Packages
	+ 识别出主要的子系统，确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其他子系统
	+ 在每个子系统的内部可能要用到不同的设计方法——请对系统中的每一部分选用最恰当的方法
	+ 不同子系统之间相互通信的规则特别重要。如果所有的子系统都能同其他子系统通信，你就完全失去了把它们分开所带来的好处。应该通过限制子系统之间的通信来让每个子系统更有存在意义
	+ 为了让自从之间的连接简单易懂且易于维护，就要尽量简化子系统之间的交互关系
	+ 一个很好的基本原则是使用**无环图(acyclic graph)**来进行系统层设计
+ 第 3 层：分解为类 Division into Classes
	+ 识别出系统中所有的类
	+ 当定义子系统中的类时，也就同时定义了这些类与系统的其余部分打交道的细节
+ 第 4 层：分解成子程序 Division into Routines
	+ 把每个类细分为子程序
	+ 完整地定义出类内部的子程序，常常会有助于更好地理解类的接口，反过来，这又有助于对类的接口进行进一步的修改
+ 第 5 层：子程序内部的设计 Internal Routine Design
	+ 为每个子程序布置详细的功能
	+ 编写伪代码、选择算法、组织子程序内部的代码块，以及用编程语言编写代码

### 设计构造块：启发式方法 Design Building Blocks: Heuristics

下面是一些思考问题的方法

+ **找出现实世界中的对象 Find Real-World Objects**
	+ 辨识对象及其属性
	+ 确定可以对各个对象进行的操作
	+ 确定各个对象能对其他对象进行的操作
	+ 确定对象的哪些部分对其他对象可见
	+ 定义每个对象的公开接口
+ **形成一致的抽象 Form Consistent Abstractions**
+ **封装实现细节 Encapsulate Implementation Details**
+ **当继承能简化设计时就继承 Inherit-When Inheritance Simplifies the Design**
+ **隐藏秘密(信息隐藏) Hide Secrets(Information Hiding)**
	+ 两种方式：隐藏复杂度，隐藏变化源
	+ 障碍：信息过度分散，循环依赖，把类内数据误认为全局数据，可以察觉的性能损耗
+ **找出容易改变的区域 Identify Areas Likely to Change**
	1. 找出看起来容易变化的项目
	2. 把容易变化的项目分类出来
	3. 把看起来容易变化的项目隔离开来
	4. 一些容易发生变化的区域：业务规则，对硬件的依赖性，输入和输出，非标准的语言特性，困难的设计区域和构建区域，状态变量，数据量的限制
+ **保持松散耦合 Keep Coupling Loose**
	+ 耦合标准：规模，可见性，灵活性
	+ 耦合的种类：简单数据参数耦合，简单对象耦合，对象参数耦合，语义上的耦合
+ **查阅常用的设计模式 Look for Common Design Patterns**
	+ Abstract Factory: 通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象
	+ Adapter: 把一个类的接口转变为另一个接口
	+ Bridge: 把接口和实现分离开来，使他们可以独立地变化
	+ Composite: 创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无需考虑所有的细节对象
	+ Decorator: 给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类
	+ Facade: 为没有提供一致接口的代码提供一个一致的接口
	+ Factory Method: 做特定基类的派生类的实例化时，除了在 Factory Method 内部之外均无须了解各派生类对象的具体类型
	+ Iterator: 提供一个服务对戏那个来顺序地访问一组元素中的各个元素
	+ Observer: 使一组相关对象互相同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象
	+ Singleton: 为有且仅有一个实例的类提供一种全局访问功能
	+ Strategy: 定义一组算法或者行为，使得它们可以动态地相互替换
	+ Template Method: 定义一个操作的算法结构，但是把部分实现的细节留给子类
+ **其他的启发式方法 Other Heuristics**
	+ 高内聚性 Aim for Strong Cohesion
	+ 构造分层结构 Build Hierarchies
	+ 严格描述类契约 Formalize Class Contracts
	+ 分配职责 Assign Responsibilities
	+ 为测试而设计 Design for Test
	+ 避免失误 Avoid Failure
	+ 有意识地选择绑定时间 Choose Binding Time Consciously
	+ 创建中央控制点 Make Central Points of Control
	+ 考虑使用蛮力突破 Consider Using Brute Force
	+ 画一个图 Draw a Diagram
	+ 保持设计的模块化 Keep Your Design Modular

### 要点

+ 软件的首要使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助
+ 简单性可以通过两种方式来获取：一是减少在同一时间所关注的本质性复杂度的量，而是避免生成不必要的偶然的复杂度
+ 设计是一种启发式的过程。固执与某一种单一方法会损害创新能力，从而损害你的程序
+ 好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好
+ 信息隐藏是个非常有价值的概念。通过询问『我该隐藏些什么？』能够解决很多困难的设计问题
+ 很多有用有趣的、关于设计的信息存在于本书之外。这里所给出的观点只是对这些有价值资源的一点提示而已

## 第 6 章 可以工作的类 Working Classes

### 类的基础：抽象数据类型(ADTs) Class Foundations: Abstract Data Types

ADT 是指一些数据以及对这些数据所进行的操作的集合。举个例子，假设要写一个程序，用不同的字体、字号和文字属性来控制显示在屏幕上的文本。如果你用一个 ADT，就能有捆绑在相关数据上的一组操作字体的子程序，这些子程序和数据集合为一体，就是一个 ADT。

如果不使用 ADT，就要用一种拼凑的方法来操作字体，代码可能是这样的

```
currentFont.size = 12
currentFont.attribute = BOLD
```

而如果使用 ADT，代码可能是这样的

```
currentFont.setSize(12)
currentFont.setBoldOn()
```

这些子程序里的代码可能很短，但是对于字体的操作都被隔离出来了，也就是提供了更好的抽象层，同时也可以在针对字体的操作发生时提供一层保护。

根据这个例子，可以得到如下的指导建议：

+ 把常见的底层数据类型创建为 ADT 并使用这些 ADT，而不再使用底层数据类型
+ 把像文件这样的常见对象当成 ADT
+ 简单的事物也可以当做 ADT
+ 不要让 ADT 依赖于其存储介质

### 良好的类接口 Good Class Interfaces

创建一个可以通过接口来展现的合理的抽象，并确保细节仍被隐藏在抽象背后。一些指导建议：

+ **类的接口应该展现一致的抽象层次**。每一个类应该实现一个 ADT，并且仅实现这个 ADT
+ **一定要理解类所实现的抽象是什么**
+ **提供成对的服务**。大多数操作都有和其相应的、相等的以及相反的操作
+ **把不相关的信息转移到其他类中**
+ **尽可能让接口可编程，而不是表达语义**
+ **谨防在修改时破坏接口的抽象**
+ **不要添加与接口抽象不一致的公用成员**
+ **同时考虑抽象性和内聚性**

### 良好的封装 Good Encapsulation

封装是一个比抽象更强的概念。抽象通过提供一个让你忽略实现细节的模型来管理复杂度，而封装则强制阻止你看到细节，下面是一些指导建议：

+ **尽可能地限制类和成员的可访问性** 
+ **不要公开暴露成员数据**
+ **避免把私用的实现细节放入类的接口中**
+ **不要对类的使用者做出任何假设**
+ **避免使用友元类(friend class)**
+ **不要因为一个子程序里仅使用公用子程序，就把它归入公开接口**
+ **让阅读代码比编写代码更方便**
+ **要格外警惕从语义上破坏封装性**
+ **留意过于紧密的耦合关系**

### 有关设计和实现的问题 Design and Implementation Issues

+ **包含(『有一个....』的关系) Containment("has a" Relationships)**
	+ 在万不得已时通过 private 继承来实现『有一个』的关系
	+ 警惕有超过约 7 个数据成员的类
+ **继承(『是一个...』关系) Inheritance("is a" Relationship)**
	+ 用 public 集成来实现『是一个...』的关系
	+ 要么使用继承并进行详细说明，要么就不要用
	+ 遵循 Liskov 替换原则(Liskov Substitution Principle, LSP)
		+ 派生类必须能通过基类的接口而被使用，且使用者无须了解两者之间的差异
	+ 确保只继承需要继承的部分
	+ 不要『覆盖』一个不可覆盖的成员函数
	+ 把共用的接口、数据及操作放到继承树中尽可能高的位置
	+ 只有一个实例的类是值得怀疑的
	+ 只有一个派生类的基类也值得怀疑
	+ 派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑
	+ 避免让继承体系过深
	+ 尽量使用多态，避免大量的类型检查
+ **成员函数和数据成员 Member Functions and Data**
	+ 让类中子程序的数量尽可能少
	+ 禁止隐式地产生你不需要的成员函数和运算符
	+ 减少类所调用的不同子程序的数量
	+ 对其他类的子程序的间接调用要尽可能少
+ **构造函数 Constructors**
	+ 如果可能，应该在所有的构造函数中初始化所有的数据成员
	+ 用私有(private) 构造函数来实现 singleton 属性
	+ 优先采用 deep copies，除非论证可行，才采用 shallow copy 

### 创建类的原因 Reasons to Create a Class

+ 对现实世界中的对象建模
+ 对抽象对象建模
+ 降低复杂度
+ 隔离复杂度
+ 隐藏实现细节
+ 限制变化所影响的范围
+ 隐藏全局数据
+ 让参数传递更顺畅
+ 创建中心控制点
+ 让代码更易于重用
+ 为程序族做计划
+ 把相关操作放到一起
+ 实现特定的重构

应该避免的类

+ 避免创建万能类
+ 消除无关紧要的类
+ 避免用动词命名的类

### 与具体编程语言相关的问题 Language-Specific Issues

下面列出跟类相关的，不同语言之间有着显著差异的一些地方：

+ 在继承层次中被覆盖的构造函数和析构函数的行为
+ 在异常处理时构造函数和析构函数的行为
+ 默认构造函数的重要性
+ 析构函数或终结器(finalizer)的调用时机
+ 和覆盖语言内置的运算符相关的知识
+ 当对象被创建和销毁时，或当其被声明时，或者它所在的作用域退出时，处理内存的方式

### 要点

+ 类的接口应提供一致的抽象。很多问题都是由于违背该原则而引起的
+ 类的接口应隐藏一些信息——如某个系统接口、某项设计决策、或一些实现细节
+ 包含往往比继承更为可取——除非你要对『是一个/is a』的关系建模
+ 继承是一种有用的工具，但它会增加复杂度，这有违于软件的首要技术使命——管理复杂度
+ 类是管理复杂度的首选工具。要在设计类时给予足够的关注，才能实现这个目标

## 第 7 章 高质量的子程序 High-Quality Routines

什么是『子程序(rountine)』？子程序是为实现一个特定的目的而编写的一个可被调用的方法(method)或过程(procedure)。例如 C++ 中的函数(function)，Java 中的方法(method)。


### 创建子程序的理由 Summary of Reasons to Create a Routine

+ 降低复杂度
+ 引入中间的、易懂的抽象
+ 避免代码重复
+ 支持子类化
+ 隐藏顺序
+ 隐藏指针操作
+ 提高可移植性
+ 简化复杂的逻辑判断
+ 改善性能
+ 隔离复杂度
+ 隐藏实现细节
+ 限制变化所带来的影响
+ 隐藏全局数据
+ 形成中央控制点
+ 促成可重用的代码
+ 达到特定的重构目的

### 在子程序层上设计 Design at the Routine Level

**功能的内聚性(functional cohesion)**：最强也是最好的一种内聚性，也就是说让一个子程序只进行一项操作。

+ 好的子程序名字 Good Routine Names
	+ 描述子程序所做的所有事情
	+ 避免使用无意义的、模糊或表叔不清的动词
	+ 不要仅通过数字来形成不同的子程序名字
	+ 根据需要确定子程序名字的长度
	+ 给函数命名时要对返回值有所描述
	+ 给过程起名时使用语气强烈的动词加宾语的形式
	+ 准确使用对仗词
	+ 为常用操作确立命名规则

**子程序最好不要超过 200 行**

+ 如何使用子程序参数 How to Use Routine Parameters
	+ 按照输入-修改-输出的顺序排列参数
	+ 考虑自己创建 in 和 out 关键字
	+ 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致
	+ 使用所有的参数
	+ 把状态或出错变量放在最后
	+ 不要把子程序的参数用做工作变量
	+ 在接口中对参数的假定加以说明
	+ 把子程序的参数个数限制在大约 7 个以内
	+ 考虑对参数采用某种表示输入、修改、输出的命名规则
	+ 为子程序传递用以维持其接口抽象的变量或对象
	+ 使用具名参数
	+ 确保实际参数与形式参数相匹配

### 使用函数时要特别考虑的问题 Special Considerations in the Use of Functions




