# 代码大全(第二版) Code Complete

在这里不会按照书本的分类每一章都进行总结，而是挑选那些在我现在的水平看来比较有意义，还不算过时的内容。并且关于概念等大道理的部分会比较简略，重点会着眼与编码的一些经验和技巧

## 第 1 章 欢迎进入软件构建的世界 Welcome to Software Construction

+ 软件构建是软件开发的核心活动；构建活动是每个项目中唯一一项必不可少的工作
+ 构建活动主要是编码与调试，但也涉及详细设计、规划构建、单元测试、集成、集成测试等其他活动
+ 构建也常被称作『编码』和『编程』
+ 构建活动的质量对软件的质量有着实质性的影响
+ 你对『如何进行构建』的理解程度，决定了你这名程序员的优秀程度

## 第 2 章 用隐喻来更充分地理解软件开发 Metaphors for a Richer Understanding of Software Development

重要的研发成果常常来自类比(analogy)。你对隐喻有多理解，也就决定了你对软件开发有多理解。

+ 隐喻是启示而不是算法，因此它们往往有一点随意(sloopy)
+ 隐喻把软件开发过程与其他你熟悉的活动联系在一起，帮助你更好地理解
+ 有些隐喻比其他一些隐喻更贴切
+ 通过把软件的构建过程比作是房屋的建设过程，我们可以发现，仔细的准备是必要的，而大型项目和小型项目之间也是有差异的
+ 通过把软件开发中的实践比作是智慧工具箱中的工具，我们又发现，每位程序员都有许多工具，但并不存在任何一个能适用于所有工作的工具，因地制宜地选择正确的工具是成为能有效编程的程序员的关键
+ 不同的隐喻并不排斥，应当使用对你最有益处的某种隐喻组合

## 第 3 章 三思而后行：前期准备 Measure Twice, Cut Once: Upstream Prerequisites

### 架构的典型组成部分 Typical Architectual Components

+ 程序组织 Program Organization
	+ 应该明确定义各个构造快的责任。每个构造快应该负责一个区域的事情，并且对其他构造块负责的区域知道的越少越好
+ 主要的类 Major Classes
+ 数据设计 Data Design
	+ 数据通常只应该由一个子系统或一个类直接访问
+ 业务规则 Business Rules
+ 用户界面设计 User Interface Design
	+ 架构应该模块化，以便在替换为新用户界面时不影响业务规则和程序的输出部分
+ 资源管理 Resource Management
+ 安全性 Security
+ 性能 Performance
+ 可伸缩性 Scalability
+ 互用性 Interoperability
+ 国际化/本地化 Internationalization/Localization
+ 输入输出 Input/Output
+ 错误处理 Error Processing
+ 容错性 Fault Tolerance
+ 架构的可行性 Architectural Feasibility
+ 过度工程 Overengineering
+ 关于『买』还是『造』的决策 Buy-vs.-Build Decisions
+ 关于复用的决策 Reuse Decisions
+ 变更策略 Change Strategy
+ 架构的总体质量 General Architectural Quality

### 要点

+ 构建活动的准备工作的根本目标在于降低风险
+ 软件开发过程必须由始至终关注质量。在项目初期关注质量，对产品质量的正面影响比在项目末期关注质量的影响要大
+ 如果没有明确的问题定义，那么你可能会在构建期间解决错误的问题
+ 如果没有做完良好的需求分析工作，你可能没能察觉待解决的问题的重要细节
+ 如果没有做完良好的架构设计，你可能会在构建期间用错误的方法解决正确的问题
+ 理解项目的前期准备所采用的方法，并相应地选择构建方法

## 第 4 章 关键的『构建』决策 Key Construction Decisions

+ 每种编程语言都有其优点和弱点
+ 在开始编程之前，做好一些约定(convention)
+ 『构建的实践方法』的种类比任何单个项目能用到的要多。有意识地选择最适合你的项目的实践方法
+ 记得『深入一种语言去编程』，不要仅『在一种语言上编程』
+ 你在技术浪潮中的位置决定了哪种方法是有效的——甚至是可能用到的。确定你在技术浪潮中的位置，并相应调整计划和预期目标

---

## 第 5 章 软件构建中的设计 Design in Construction

### 理想的设计特征 Desirable Characteristics of a Design

+ **最小的复杂度(Minimal complexity)**。应该做出简单且易于理解的设计。如果你的设计方案不能让你在专注于程序的一部分时安心地忽视其他部分的话，这一设计就没有什么作用
+ **易于维护(Ease of maintenance)**。设计出能自明(self-explanatory)的系统
+ **松散耦合(Loose coupling)**。设计时让程序的各个组成部分之间关联最小。通过应用类接口中的合理抽象、封装性及信息隐藏等原则，设计出相互关联尽可能最少的类。减少关联也就减少了集成、测试与维护时的工作量
+ **可拓展性(Extensibility)**。能够增强系统的功能而无须破坏其底层结构
+ **可重用性(Reusability)**。所设计的系统的组成部分能在其他系统中重复使用
+ **高扇入(High fan-in)**。让大量的类使用某个给定的类。这意味着设计出的系统很好地利用了在较低层次上的工具类(utility classes)
+ **低扇出(Low fan-out)**。让一个类里少量或适中地使用其他的类
+ **可移植性(Portability)**。应该这样设计系统，使它能很方便地移植到其他环境中
+ **精简性(Leanness)**。设计出的系统没有多余的部分
+ **层次性(Stratification)**。尽量保持系统各个分解层的层次性，使你能在任意的层面上观察系统，并得到某种具有一致性的看法
+ **标准技术(Standard techniques)**。一个系统所依赖的外来的、古怪的东西越多，别人在第一次想要理解它的时候就越是头疼。要尽量用标准化的、常用的方法，让整个系统给人一种熟悉的感觉

### 设计的层次 Levels of Design

一个程序中的设计层次。**系统**首先被组织为**子系统**；**子系统**被进一步分解为**类**，然后**类**又被分解为**子程序**和**数据**。每个**子程序**的内部也需要进行设计。

+ 第 1 层：软件系统 Software System
	+ 先从子系统或者**包(package)**这些类的更高组织层次来思考会更有益处
+ 第 2 层：分解为子系统或包 Division into Subsystems or Packages
	+ 识别出主要的子系统，确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其他子系统
	+ 在每个子系统的内部可能要用到不同的设计方法——请对系统中的每一部分选用最恰当的方法
	+ 不同子系统之间相互通信的规则特别重要。如果所有的子系统都能同其他子系统通信，你就完全失去了把它们分开所带来的好处。应该通过限制子系统之间的通信来让每个子系统更有存在意义
	+ 为了让自从之间的连接简单易懂且易于维护，就要尽量简化子系统之间的交互关系
	+ 一个很好的基本原则是使用**无环图(acyclic graph)**来进行系统层设计
+ 第 3 层：分解为类 Division into Classes
	+ 识别出系统中所有的类
	+ 当定义子系统中的类时，也就同时定义了这些类与系统的其余部分打交道的细节
+ 第 4 层：分解成子程序 Division into Routines
	+ 把每个类细分为子程序
	+ 完整地定义出类内部的子程序，常常会有助于更好地理解类的接口，反过来，这又有助于对类的接口进行进一步的修改
+ 第 5 层：子程序内部的设计 Internal Routine Design
	+ 为每个子程序布置详细的功能
	+ 编写伪代码、选择算法、组织子程序内部的代码块，以及用编程语言编写代码

### 设计构造块：启发式方法 Design Building Blocks: Heuristics

下面是一些思考问题的方法

+ **找出现实世界中的对象 Find Real-World Objects**
	+ 辨识对象及其属性
	+ 确定可以对各个对象进行的操作
	+ 确定各个对象能对其他对象进行的操作
	+ 确定对象的哪些部分对其他对象可见
	+ 定义每个对象的公开接口
+ **形成一致的抽象 Form Consistent Abstractions**
+ **封装实现细节 Encapsulate Implementation Details**
+ **当继承能简化设计时就继承 Inherit-When Inheritance Simplifies the Design**
+ **隐藏秘密(信息隐藏) Hide Secrets(Information Hiding)**
	+ 两种方式：隐藏复杂度，隐藏变化源
	+ 障碍：信息过度分散，循环依赖，把类内数据误认为全局数据，可以察觉的性能损耗
+ **找出容易改变的区域 Identify Areas Likely to Change**
	1. 找出看起来容易变化的项目
	2. 把容易变化的项目分类出来
	3. 把看起来容易变化的项目隔离开来
	4. 一些容易发生变化的区域：业务规则，对硬件的依赖性，输入和输出，非标准的语言特性，困难的设计区域和构建区域，状态变量，数据量的限制
+ **保持松散耦合 Keep Coupling Loose**
	+ 耦合标准：规模，可见性，灵活性
	+ 耦合的种类：简单数据参数耦合，简单对象耦合，对象参数耦合，语义上的耦合
+ **查阅常用的设计模式 Look for Common Design Patterns**
	+ Abstract Factory: 通过指定对象组的种类而非单个对象的类型来支持创建一组相关的对象
	+ Adapter: 把一个类的接口转变为另一个接口
	+ Bridge: 把接口和实现分离开来，使他们可以独立地变化
	+ Composite: 创建一个包含其他同类对象的对象，使得客户代码可以与最上层对象交互而无需考虑所有的细节对象
	+ Decorator: 给一个对象动态地添加职责，而无须为了每一种可能的职责配置情况去创建特定的子类
	+ Facade: 为没有提供一致接口的代码提供一个一致的接口
	+ Factory Method: 做特定基类的派生类的实例化时，除了在 Factory Method 内部之外均无须了解各派生类对象的具体类型
	+ Iterator: 提供一个服务对戏那个来顺序地访问一组元素中的各个元素
	+ Observer: 使一组相关对象互相同步，方法是让另一个对象负责：在这组对象中的任何一个发生改变时，由它把这种变化通知给这个组里的所有对象
	+ Singleton: 为有且仅有一个实例的类提供一种全局访问功能
	+ Strategy: 定义一组算法或者行为，使得它们可以动态地相互替换
	+ Template Method: 定义一个操作的算法结构，但是把部分实现的细节留给子类
+ **其他的启发式方法 Other Heuristics**
	+ 高内聚性 Aim for Strong Cohesion
	+ 构造分层结构 Build Hierarchies
	+ 严格描述类契约 Formalize Class Contracts
	+ 分配职责 Assign Responsibilities
	+ 为测试而设计 Design for Test
	+ 避免失误 Avoid Failure
	+ 有意识地选择绑定时间 Choose Binding Time Consciously
	+ 创建中央控制点 Make Central Points of Control
	+ 考虑使用蛮力突破 Consider Using Brute Force
	+ 画一个图 Draw a Diagram
	+ 保持设计的模块化 Keep Your Design Modular

### 要点

+ 软件的首要使命就是管理复杂度。以简单性作为努力目标的设计方案对此最有帮助
+ 简单性可以通过两种方式来获取：一是减少在同一时间所关注的本质性复杂度的量，而是避免生成不必要的偶然的复杂度
+ 设计是一种启发式的过程。固执与某一种单一方法会损害创新能力，从而损害你的程序
+ 好的设计都是迭代的。你尝试设计的可能性越多，你的最终设计方案就会变得越好
+ 信息隐藏是个非常有价值的概念。通过询问『我该隐藏些什么？』能够解决很多困难的设计问题
+ 很多有用有趣的、关于设计的信息存在于本书之外。这里所给出的观点只是对这些有价值资源的一点提示而已

## 第 6 章 可以工作的类 Working Classes



